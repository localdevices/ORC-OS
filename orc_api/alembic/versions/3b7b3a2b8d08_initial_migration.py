"""Initial migration

Revision ID: 3b7b3a2b8d08
Revises:
Create Date: 2025-07-11 18:27:47.405051

"""

from typing import Sequence, Union

import sqlalchemy as sa

from alembic import op

# revision identifiers, used by Alembic.
revision: str = "3b7b3a2b8d08"
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "callback_url",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column("url", sa.String(), nullable=False, comment="url to api main end point of server to report to"),
        sa.Column(
            "token_refresh_end_point",
            sa.String(),
            nullable=False,
            comment="Refresh end point for JWT tokens of the server",
        ),
        sa.Column("token_refresh", sa.String(), nullable=True, comment="Refresh JWT token"),
        sa.Column("token_access", sa.String(), nullable=True, comment="JWT token"),
        sa.Column(
            "token_expiration", sa.DateTime(), nullable=True, comment="Date time of moment of expiry of refresh token"
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_table(
        "camera_config",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("data", sa.JSON(), nullable=False),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column("remote_id", sa.Integer(), nullable=True),
        sa.Column("sync_status", sa.Enum("LOCAL", "SYNCED", "UPDATED", "FAILED", name="syncstatus"), nullable=True),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("remote_id"),
    )
    op.create_index(op.f("ix_camera_config_sync_status"), "camera_config", ["sync_status"], unique=False)
    op.create_table(
        "cross_section",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("timestamp", sa.DateTime(), nullable=False),
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("features", sa.JSON(), nullable=False),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column("remote_id", sa.Integer(), nullable=True),
        sa.Column("sync_status", sa.Enum("LOCAL", "SYNCED", "UPDATED", "FAILED", name="syncstatus"), nullable=True),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("remote_id"),
    )
    op.create_index(op.f("ix_cross_section_sync_status"), "cross_section", ["sync_status"], unique=False)
    op.create_table(
        "device",
        sa.Column("id", sa.Uuid(), nullable=False),
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column("operating_system", sa.String(), nullable=False),
        sa.Column("processor", sa.String(), nullable=False),
        sa.Column("memory", sa.Float(), nullable=False),
        sa.Column("free_storage", sa.Float(), nullable=False),
        sa.Column(
            "status",
            sa.Enum("HEALTHY", "LOW_VOLTAGE", "LOW_STORAGE", "CRITICAL_STORAGE", name="devicestatus"),
            nullable=False,
        ),
        sa.Column(
            "form_status",
            sa.Enum("NOFORM", "VALID_FORM", "INVALID_FORM", "BROKEN_FORM", name="deviceformstatus"),
            nullable=False,
        ),
        sa.Column("orc_os_version", sa.String(), nullable=False),
        sa.Column("message", sa.String(), nullable=True),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_table(
        "disk_management",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column(
            "min_free_space",
            sa.Float(),
            nullable=False,
            comment="GB of minimum free space required. When space is less, cleanup will be performed",
        ),
        sa.Column(
            "critical_space",
            sa.Float(),
            nullable=False,
            comment="GB of free space under which the service will shutdown to prevent loss of contact to the device",
        ),
        sa.Column(
            "frequency",
            sa.Float(),
            nullable=False,
            comment="Frequency [s] in which the device will be checked for available space and cleanup will occur",
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_table(
        "recipe",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("data", sa.JSON(), nullable=False),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column("remote_id", sa.Integer(), nullable=True),
        sa.Column("sync_status", sa.Enum("LOCAL", "SYNCED", "UPDATED", "FAILED", name="syncstatus"), nullable=True),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("remote_id"),
    )
    op.create_index(op.f("ix_recipe_sync_status"), "recipe", ["sync_status"], unique=False)
    op.create_table(
        "time_series",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("timestamp", sa.DateTime(), nullable=False),
        sa.Column("h", sa.Float(), nullable=False),
        sa.Column("q_05", sa.Float(), nullable=True),
        sa.Column("q_25", sa.Float(), nullable=True),
        sa.Column("q_50", sa.Float(), nullable=True),
        sa.Column("q_75", sa.Float(), nullable=True),
        sa.Column("q_95", sa.Float(), nullable=True),
        sa.Column("q_raw", sa.Float(), nullable=True),
        sa.Column("v_av", sa.Float(), nullable=True),
        sa.Column("v_bulk", sa.Float(), nullable=True),
        sa.Column("wetted_surface", sa.Float(), nullable=True),
        sa.Column("wetted_perimeter", sa.Float(), nullable=True),
        sa.Column("fraction_velocimetry", sa.Float(), nullable=True),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column("remote_id", sa.Integer(), nullable=True),
        sa.Column("sync_status", sa.Enum("LOCAL", "SYNCED", "UPDATED", "FAILED", name="syncstatus"), nullable=True),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("remote_id"),
    )
    op.create_index(op.f("ix_time_series_sync_status"), "time_series", ["sync_status"], unique=False)
    op.create_index(op.f("ix_time_series_timestamp"), "time_series", ["timestamp"], unique=False)
    op.create_table(
        "water_level_settings",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column(
            "frequency",
            sa.Float(),
            nullable=False,
            comment="Frequency [s] in which a device or API will be checked for available water level files and water level entries will be added to the database, using the scripts. ",
        ),
        sa.Column(
            "script_type",
            sa.Enum("PYTHON", "BASH", name="scripttype"),
            nullable=False,
            comment="Type of script used to retrieve water level data from the device or API. Either 'PYTHON' or 'BASH'.",
        ),
        sa.Column(
            "script",
            sa.String(),
            nullable=False,
            comment='Content of the script to be executed to retrieve water level data from the device or API. Script must print a water level value to stdout in the form "%Y-%m-%dT%H:%M:%SZ, <value>"',
        ),
        sa.Column(
            "optical",
            sa.Boolean(),
            nullable=False,
            comment="Whether to measure water level optically if no water level can be retrieved from the database or files. ",
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_table(
        "video",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("timestamp", sa.DateTime(), nullable=False),
        sa.Column("status", sa.Enum("NEW", "QUEUE", "TASK", "DONE", "ERROR", name="videostatus"), nullable=False),
        sa.Column("file", sa.String(), nullable=True),
        sa.Column("image", sa.String(), nullable=True),
        sa.Column("thumbnail", sa.String(), nullable=True),
        sa.Column("video_config_id", sa.Integer(), nullable=True),
        sa.Column("time_series_id", sa.Integer(), nullable=True),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column("remote_id", sa.Integer(), nullable=True),
        sa.Column("sync_status", sa.Enum("LOCAL", "SYNCED", "UPDATED", "FAILED", name="syncstatus"), nullable=True),
        sa.ForeignKeyConstraint(
            ["time_series_id"],
            ["time_series.id"],
        ),
        sa.ForeignKeyConstraint(["video_config_id"], ["video_config.id"], use_alter=True),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("remote_id"),
        sa.UniqueConstraint("time_series_id"),
    )
    op.create_index(op.f("ix_video_status"), "video", ["status"], unique=False)
    op.create_index(op.f("ix_video_sync_status"), "video", ["sync_status"], unique=False)
    op.create_index(op.f("ix_video_timestamp"), "video", ["timestamp"], unique=False)
    op.create_table(
        "video_config",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("name", sa.String(), nullable=False, comment="Named description of the video configuration"),
        sa.Column("camera_config_id", sa.Integer(), nullable=True),
        sa.Column("recipe_id", sa.Integer(), nullable=True),
        sa.Column("cross_section_id", sa.Integer(), nullable=True),
        sa.Column("cross_section_wl_id", sa.Integer(), nullable=True),
        sa.Column(
            "sample_video_id", sa.Integer(), nullable=True, comment="Video containing sampling information such as GCPs"
        ),
        sa.Column(
            "rvec", sa.JSON(), nullable=False, comment="Rotation vector for matching CrossSection with CameraConfig"
        ),
        sa.Column(
            "tvec", sa.JSON(), nullable=False, comment="Translation vector for matching CrossSection with CameraConfig"
        ),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column("remote_id", sa.Integer(), nullable=True),
        sa.Column("sync_status", sa.Enum("LOCAL", "SYNCED", "UPDATED", "FAILED", name="syncstatus"), nullable=True),
        sa.ForeignKeyConstraint(
            ["camera_config_id"],
            ["camera_config.id"],
        ),
        sa.ForeignKeyConstraint(
            ["cross_section_id"],
            ["cross_section.id"],
        ),
        sa.ForeignKeyConstraint(
            ["cross_section_wl_id"],
            ["cross_section.id"],
        ),
        sa.ForeignKeyConstraint(
            ["recipe_id"],
            ["recipe.id"],
        ),
        sa.ForeignKeyConstraint(["sample_video_id"], ["video.id"], ondelete="RESTRICT"),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("remote_id"),
    )
    op.create_index(op.f("ix_video_config_sync_status"), "video_config", ["sync_status"], unique=False)
    op.create_table(
        "settings",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column(
            "parse_dates_from_file",
            sa.Boolean(),
            nullable=False,
            comment="Flag determining if dates should be read from a datestring in the filename (True, default) or from the file metadata (False)",
        ),
        sa.Column(
            "video_file_fmt",
            sa.String(),
            nullable=False,
            comment="Filename template (excluding path) defining the file name convention of video files. The template contains a datestring format in between {} signs, e.g. video_{%Y%m%dT%H%M%S}.mp4",
        ),
        sa.Column(
            "allowed_dt",
            sa.Float(),
            nullable=False,
            comment="Float indicating the maximum difference in time allowed between a videofile time stamp and a water level time stamp to match them",
        ),
        sa.Column(
            "shutdown_after_task",
            sa.Boolean(),
            nullable=False,
            comment="Flag for enabling automated shutdown after a task is performed. Must only be used if a power cycling scheme is implemented and is meant to save power only.",
        ),
        sa.Column(
            "reboot_after",
            sa.Float(),
            nullable=False,
            comment="Float indicating the amount of seconds after which device reboots (0 means never reboot)",
        ),
        sa.Column(
            "enable_daemon",
            sa.Boolean(),
            nullable=False,
            comment="Flag for enabling the daemon. If disabled, the daemon will not be started and the service will only run in the foreground. A Video Config must be selected to process videos.",
        ),
        sa.Column("video_config_id", sa.Integer(), nullable=True, comment="Video Config ID used to process videos."),
        sa.Column(
            "remote_site_id",
            sa.Integer(),
            nullable=True,
            comment="Remote site id to sent data to. Needed in order to automatically send data to end points",
        ),
        sa.Column("sync_file", sa.Boolean(), nullable=False, comment="Flag for syncing video files to remote server"),
        sa.Column("sync_image", sa.Boolean(), nullable=False, comment="Flag for syncing images to remote server"),
        sa.Column(
            "active",
            sa.Boolean(),
            nullable=False,
            comment="Flag for enabling the daemon. If disabled, the daemon will not be started and only interactive processing is done.",
        ),
        sa.ForeignKeyConstraint(
            ["video_config_id"],
            ["video_config.id"],
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table("settings")
    op.drop_index(op.f("ix_video_config_sync_status"), table_name="video_config")
    op.drop_table("video_config")
    op.drop_index(op.f("ix_video_timestamp"), table_name="video")
    op.drop_index(op.f("ix_video_sync_status"), table_name="video")
    op.drop_index(op.f("ix_video_status"), table_name="video")
    op.drop_table("video")
    op.drop_table("water_level_settings")
    op.drop_index(op.f("ix_time_series_timestamp"), table_name="time_series")
    op.drop_index(op.f("ix_time_series_sync_status"), table_name="time_series")
    op.drop_table("time_series")
    op.drop_index(op.f("ix_recipe_sync_status"), table_name="recipe")
    op.drop_table("recipe")
    op.drop_table("disk_management")
    op.drop_table("device")
    op.drop_index(op.f("ix_cross_section_sync_status"), table_name="cross_section")
    op.drop_table("cross_section")
    op.drop_index(op.f("ix_camera_config_sync_status"), table_name="camera_config")
    op.drop_table("camera_config")
    op.drop_table("callback_url")
    # ### end Alembic commands ###
